# üéØ ASISTENTE DEPORTIVO IA v4.0 - VERSI√ìN MEJORADA PARA RENDER
# ============================================================================
# Sistema completo de an√°lisis deportivo con IA y notificaciones autom√°ticas

import os
import requests
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import logging
import json
from typing import Dict, List, Any
import schedule
import time
from flask import Flask, jsonify, render_template_string, request
from flask_cors import CORS
import threading
from dataclasses import dataclass
import pytz
import warnings
warnings.filterwarnings('ignore')

# Configurar logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Crear la aplicaci√≥n Flask
app = Flask(__name__)
CORS(app)

# Configuraci√≥n de zona horaria (Colombia)
TIMEZONE = pytz.timezone('America/Bogota')

@dataclass
class Partido:
    """Representa un partido deportivo"""
    id: str
    deporte: str
    liga: str
    equipo_local: str
    equipo_visitante: str
    fecha_hora: datetime
    odds_local: float
    odds_empate: float
    odds_visitante: float
    estadisticas: Dict
    prediccion: Dict = None

class AsistenteDeportivoIA:
    """ü§ñ Asistente inteligente para an√°lisis deportivo y apuestas"""
    
    def __init__(self):
        logger.info("üöÄ Iniciando Asistente Deportivo IA v4.0")
        
        # URLs para notificaciones (configurables via variables de entorno)
        self.webhook_url = os.getenv('WEBHOOK_URL', '')
        self.telegram_token = os.getenv('TELEGRAM_TOKEN', '')
        self.telegram_chat_id = os.getenv('TELEGRAM_CHAT_ID', '')
        
        # Cache de datos
        self.ultimo_analisis = None
        self.ultima_actualizacion = None
        self.notificaciones_enviadas = []
        
        # Configuraci√≥n de horarios (7 AM a 12 AM)
        self.hora_inicio = 7
        self.hora_fin = 24

    def es_horario_activo(self) -> bool:
        """‚è∞ Verifica si estamos en horario activo"""
        ahora = datetime.now(TIMEZONE)
        hora_actual = ahora.hour
        es_activo = self.hora_inicio <= hora_actual < self.hora_fin
        logger.info(f"‚è∞ Hora actual: {hora_actual}:00 - Horario activo: {'S√ç' if es_activo else 'NO'}")
        return es_activo

    def obtener_partidos_12h(self) -> List[Partido]:
        """üìÖ Obtiene partidos de las pr√≥ximas 12 horas con datos realistas"""
        logger.info("üìÖ Generando partidos de las pr√≥ximas 12 horas...")
        
        partidos = []
        fecha_inicio = datetime.now(TIMEZONE)
        fecha_fin = fecha_inicio + timedelta(hours=12)
        
        # Generar partidos realistas
        partidos.extend(self._generar_partidos_futbol(fecha_inicio, fecha_fin))
        partidos.extend(self._generar_partidos_basketball(fecha_inicio, fecha_fin))
        partidos.extend(self._generar_partidos_tennis(fecha_inicio, fecha_fin))
        
        logger.info(f"‚úÖ {len(partidos)} partidos generados para an√°lisis")
        return partidos

    def _generar_partidos_futbol(self, inicio, fin) -> List[Partido]:
        """‚öΩ Genera partidos de f√∫tbol con datos realistas"""
        partidos = []
        
        # Ligas y equipos reales
        ligas_config = {
            'Liga BetPlay (Colombia)': {
                'equipos': [
                    'Atl√©tico Nacional', 'Millonarios FC', 'Junior de Barranquilla', 'Am√©rica de Cali',
                    'Independiente Santa Fe', 'Deportivo Cali', 'Once Caldas', 'Deportivo Medell√≠n',
                    'Deportes Tolima', 'Deportivo Pereira', 'Atl√©tico Bucaramanga', 'Deportivo Pasto'
                ],
                'factor_odds': (1.8, 4.2)
            },
            'Premier League': {
                'equipos': [
                    'Manchester City', 'Arsenal', 'Liverpool', 'Chelsea', 'Manchester United',
                    'Newcastle United', 'Tottenham', 'Brighton', 'West Ham', 'Aston Villa'
                ],
                'factor_odds': (1.5, 5.0)
            },
            'Champions League': {
                'equipos': [
                    'Real Madrid', 'FC Barcelona', 'Bayern Munich', 'Paris Saint-Germain',
                    'Manchester City', 'Liverpool', 'AC Milan', 'Juventus'
                ],
                'factor_odds': (1.4, 6.0)
            }
        }
        
        # Generar 6 partidos de f√∫tbol
        for i in range(6):
            liga_nombre = np.random.choice(list(ligas_config.keys()))
            config = ligas_config[liga_nombre]
            
            local = np.random.choice(config['equipos'])
            visitante = np.random.choice([e for e in config['equipos'] if e != local])
            
            # Odds realistas seg√∫n la liga
            odds_local = round(np.random.uniform(config['factor_odds'][0], config['factor_odds'][1]), 2)
            odds_visitante = round(np.random.uniform(config['factor_odds'][0], config['factor_odds'][1]), 2)
            odds_empate = round(np.random.uniform(2.8, 4.5), 2)
            
            # Fecha y hora aleatoria en las pr√≥ximas 12 horas
            horas_adelante = np.random.randint(1, 12)
            fecha_partido = inicio + timedelta(hours=horas_adelante, minutes=np.random.randint(0, 59))
            
            partido = Partido(
                id=f"fut_{i+1}_{int(time.time())}",
                deporte="f√∫tbol",
                liga=liga_nombre,
                equipo_local=local,
                equipo_visitante=visitante,
                fecha_hora=fecha_partido,
                odds_local=odds_local,
                odds_empate=odds_empate,
                odds_visitante=odds_visitante,
                estadisticas=self._generar_stats_futbol(local, visitante)
            )
            partidos.append(partido)
        
        return partidos

    def _generar_partidos_basketball(self, inicio, fin) -> List[Partido]:
        """üèÄ Genera partidos de basketball"""
        partidos = []
        
        ligas_config = {
            'NBA': {
                'equipos': ['Lakers', 'Warriors', 'Celtics', 'Heat', 'Bulls', 'Knicks', 'Nets', 'Sixers'],
                'factor_odds': (1.4, 3.2)
            },
            'Liga Colombiana Basketball': {
                'equipos': ['Titanes de Barranquilla', 'Cimarrones', 'Piratas de Bogot√°', 'Team Cali'],
                'factor_odds': (1.6, 2.8)
            }
        }
        
        # Generar 3 partidos de basketball
        for i in range(3):
            liga_nombre = np.random.choice(list(ligas_config.keys()))
            config = ligas_config[liga_nombre]
            
            local = np.random.choice(config['equipos'])
            visitante = np.random.choice([e for e in config['equipos'] if e != local])
            
            odds_local = round(np.random.uniform(config['factor_odds'][0], config['factor_odds'][1]), 2)
            odds_visitante = round(np.random.uniform(config['factor_odds'][0], config['factor_odds'][1]), 2)
            
            fecha_partido = inicio + timedelta(hours=np.random.randint(1, 12), minutes=np.random.randint(0, 59))
            
            partido = Partido(
                id=f"bas_{i+1}_{int(time.time())}",
                deporte="basketball",
                liga=liga_nombre,
                equipo_local=local,
                equipo_visitante=visitante,
                fecha_hora=fecha_partido,
                odds_local=odds_local,
                odds_empate=0,  # Basketball no tiene empate
                odds_visitante=odds_visitante,
                estadisticas=self._generar_stats_basketball(local, visitante)
            )
            partidos.append(partido)
        
        return partidos

    def _generar_partidos_tennis(self, inicio, fin) -> List[Partido]:
        """üéæ Genera partidos de tennis"""
        partidos = []
        
        torneos = ['ATP Masters 1000', 'WTA 1000', 'Roland Garros', 'US Open', 'Wimbledon']
        jugadores_top = [
            'Novak Djokovic', 'Carlos Alcaraz', 'Daniil Medvedev', 'Stefanos Tsitsipas',
            'Andrey Rublev', 'Jannik Sinner', 'Rafael Nadal', 'Alexander Zverev'
        ]
        
        # Generar 2 partidos de tennis
        for i in range(2):
            torneo = np.random.choice(torneos)
            j1 = np.random.choice(jugadores_top)
            j2 = np.random.choice([j for j in jugadores_top if j != j1])
            
            odds_j1 = round(np.random.uniform(1.3, 4.0), 2)
            odds_j2 = round(np.random.uniform(1.3, 4.0), 2)
            
            fecha_partido = inicio + timedelta(hours=np.random.randint(1, 12), minutes=np.random.randint(0, 59))
            
            partido = Partido(
                id=f"ten_{i+1}_{int(time.time())}",
                deporte="tennis",
                liga=torneo,
                equipo_local=j1,
                equipo_visitante=j2,
                fecha_hora=fecha_partido,
                odds_local=odds_j1,
                odds_empate=0,  # Tennis no tiene empate
                odds_visitante=odds_j2,
                estadisticas=self._generar_stats_tennis(j1, j2)
            )
            partidos.append(partido)
        
        return partidos

    def _generar_stats_futbol(self, local, visitante) -> Dict:
        """üìä Genera estad√≠sticas realistas para f√∫tbol"""
        return {
            'local': {
                'forma_reciente': [np.random.choice(['V', 'E', 'D'], p=[0.4, 0.3, 0.3]) for _ in range(5)],
                'goles_favor_casa': np.random.randint(12, 28),
                'goles_contra_casa': np.random.randint(6, 20),
                'partidos_jugados_casa': np.random.randint(10, 16),
                'victorias_casa': np.random.randint(5, 13),
                'empates_casa': np.random.randint(2, 6),
                'lesionados': np.random.randint(0, 3),
                'suspendidos': np.random.randint(0, 2),
                'posesion_promedio': round(np.random.uniform(45, 65), 1),
                'tiros_por_partido': round(np.random.uniform(10, 18), 1),
                'corners_promedio': round(np.random.uniform(4, 8), 1)
            },
            'visitante': {
                'forma_reciente': [np.random.choice(['V', 'E', 'D'], p=[0.3, 0.3, 0.4]) for _ in range(5)],
                'goles_favor_visita': np.random.randint(8, 24),
                'goles_contra_visita': np.random.randint(8, 22),
                'partidos_jugados_visita': np.random.randint(10, 16),
                'victorias_visita': np.random.randint(3, 11),
                'empates_visita': np.random.randint(2, 6),
                'lesionados': np.random.randint(0, 3),
                'suspendidos': np.random.randint(0, 2),
                'posesion_promedio': round(np.random.uniform(35, 55), 1),
                'tiros_por_partido': round(np.random.uniform(8, 16), 1),
                'corners_promedio': round(np.random.uniform(3, 7), 1)
            },
            'enfrentamientos_directos': {
                'ultimos_5_resultados': [np.random.choice(['L', 'E', 'V']) for _ in range(5)],
                'goles_local_promedio': round(np.random.uniform(1.2, 2.8), 1),
                'goles_visitante_promedio': round(np.random.uniform(0.8, 2.4), 1),
                'total_enfrentamientos': np.random.randint(6, 15)
            },
            'condiciones_extra': {
                'clima': np.random.choice(['Soleado', 'Nublado', 'Lluvia ligera']),
                'temperatura': np.random.randint(18, 32),
                'motivacion_local': np.random.randint(7, 10),
                'motivacion_visitante': np.random.randint(6, 9)
            }
        }

    def _generar_stats_basketball(self, local, visitante) -> Dict:
        """üèÄ Genera estad√≠sticas para basketball"""
        return {
            'local': {
                'puntos_promedio_casa': np.random.randint(108, 125),
                'puntos_contra_casa': np.random.randint(100, 118),
                'victorias_casa': np.random.randint(18, 28),
                'derrotas_casa': np.random.randint(6, 16),
                'porcentaje_tiros_campo': round(np.random.uniform(44, 52), 1),
                'porcentaje_triples': round(np.random.uniform(32, 42), 1),
                'rebotes_promedio': round(np.random.uniform(42, 50), 1),
                'asistencias_promedio': round(np.random.uniform(22, 28), 1)
            },
            'visitante': {
                'puntos_promedio_visita': np.random.randint(102, 120),
                'puntos_contra_visita': np.random.randint(105, 122),
                'victorias_visita': np.random.randint(15, 25),
                'derrotas_visita': np.random.randint(10, 20),
                'porcentaje_tiros_campo': round(np.random.uniform(42, 50), 1),
                'porcentaje_triples': round(np.random.uniform(30, 40), 1),
                'rebotes_promedio': round(np.random.uniform(40, 48), 1),
                'asistencias_promedio': round(np.random.uniform(20, 26), 1)
            }
        }

    def _generar_stats_tennis(self, j1, j2) -> Dict:
        """üéæ Genera estad√≠sticas para tennis"""
        return {
            'jugador1': {
                'ranking_atp': np.random.randint(1, 50),
                'victorias_a√±o': np.random.randint(25, 55),
                'derrotas_a√±o': np.random.randint(8, 25),
                'sets_ganados_a√±o': np.random.randint(120, 200),
                'porcentaje_primer_saque': round(np.random.uniform(62, 78), 1),
                'aces_promedio_partido': round(np.random.uniform(8, 15), 1),
                'puntos_ganados_saque': round(np.random.uniform(75, 85), 1)
            },
            'jugador2': {
                'ranking_atp': np.random.randint(1, 50),
                'victorias_a√±o': np.random.randint(25, 55),
                'derrotas_a√±o': np.random.randint(8, 25),
                'sets_ganados_a√±o': np.random.randint(120, 200),
                'porcentaje_primer_saque': round(np.random.uniform(62, 78), 1),
                'aces_promedio_partido': round(np.random.uniform(8, 15), 1),
                'puntos_ganados_saque': round(np.random.uniform(75, 85), 1)
            },
            'enfrentamientos_directos': {
                'victorias_j1': np.random.randint(0, 8),
                'victorias_j2': np.random.randint(0, 8),
                'sets_ganados_j1': np.random.randint(0, 15),
                'sets_ganados_j2': np.random.randint(0, 15)
            }
        }

    def analizar_partido_ia(self, partido: Partido) -> Dict:
        """üß† An√°lisis completo con IA para un partido"""
        logger.info(f"üß† Analizando: {partido.equipo_local} vs {partido.equipo_visitante} ({partido.deporte})")
        
        if partido.deporte == 'f√∫tbol':
            return self._analizar_futbol_avanzado(partido)
        elif partido.deporte == 'basketball':
            return self._analizar_basketball_avanzado(partido)
        elif partido.deporte == 'tennis':
            return self._analizar_tennis_avanzado(partido)
        else:
            return self._analizar_generico(partido)

    def _analizar_futbol_avanzado(self, partido: Partido) -> Dict:
        """‚öΩ An√°lisis avanzado de f√∫tbol"""
        stats = partido.estadisticas
        
        # 1. AN√ÅLISIS DE FORMA RECIENTE (30% del peso)
        forma_local = self._calcular_forma(stats['local']['forma_reciente'])
        forma_visitante = self._calcular_forma(stats['visitante']['forma_reciente'])
        factor_forma = (forma_local - forma_visitante) * 0.30
        
        # 2. RENDIMIENTO CASA/VISITA (25% del peso)
        partidos_casa = stats['local']['partidos_jugados_casa']
        victorias_casa = stats['local']['victorias_casa']
        rendimiento_casa = (victorias_casa / partidos_casa * 100) if partidos_casa > 0 else 45
        
        partidos_visita = stats['visitante']['partidos_jugados_visita']
        victorias_visita = stats['visitante']['victorias_visita']
        rendimiento_visita = (victorias_visita / partidos_visita * 100) if partidos_visita > 0 else 30
        
        factor_casa_visita = (rendimiento_casa - rendimiento_visita) * 0.0025
        
        # 3. AN√ÅLISIS OFENSIVO/DEFENSIVO (20% del peso)
        if partidos_casa > 0:
            ataque_local = stats['local']['goles_favor_casa'] / partidos_casa
            defensa_local = stats['local']['goles_contra_casa'] / partidos_casa
        else:
            ataque_local, defensa_local = 1.5, 1.2
            
        if partidos_visita > 0:
            ataque_visitante = stats['visitante']['goles_favor_visita'] / partidos_visita
            defensa_visitante = stats['visitante']['goles_contra_visita'] / partidos_visita
        else:
            ataque_visitante, defensa_visitante = 1.2, 1.3
        
        diferencial_goles = (ataque_local - defensa_visitante) - (ataque_visitante - defensa_local)
        factor_goles = diferencial_goles * 0.15
        
        # 4. ENFRENTAMIENTOS DIRECTOS (15% del peso)
        h2h = stats['enfrentamientos_directos']['ultimos_5_resultados']
        victorias_locales_h2h = h2h.count('L')
        victorias_visitantes_h2h = h2h.count('V')
        factor_h2h = (victorias_locales_h2h - victorias_visitantes_h2h) * 0.03
        
        # 5. FACTOR BAJAS (10% del peso)
        bajas_local = stats['local']['lesionados'] + stats['local']['suspendidos']
        bajas_visitante = stats['visitante']['lesionados'] + stats['visitante']['suspendidos']
        factor_bajas = (bajas_visitante - bajas_local) * 0.025
        
        # C√ÅLCULO DE PROBABILIDADES FINALES
        ventaja_casa_base = 0.15  # 15% ventaja por jugar en casa
        prob_local_base = 0.40
        prob_empate_base = 0.25
        prob_visitante_base = 0.35
        
        # Aplicar todos los factores
        ajuste_total = factor_forma + factor_casa_visita + factor_goles + factor_h2h + factor_bajas
        
        prob_local = prob_local_base + ventaja_casa_base + ajuste_total
        prob_visitante = prob_visitante_base - (ajuste_total * 0.7)
        prob_empate = 1 - prob_local - prob_visitante
        
        # Asegurar que est√©n en rangos v√°lidos
        prob_local = max(0.10, min(0.80, prob_local))
        prob_visitante = max(0.10, min(0.80, prob_visitante))
        prob_empate = max(0.10, 1 - prob_local - prob_visitante)
        
        # Normalizar para que sumen 1
        total = prob_local + prob_empate + prob_visitante
        prob_local /= total
        prob_empate /= total
        prob_visitante /= total
        
        # C√ÅLCULO DE VALOR ESPERADO
        valor_local = self._calcular_valor_esperado(partido.odds_local, prob_local)
        valor_empate = self._calcular_valor_esperado(partido.odds_empate, prob_empate)
        valor_visitante = self._calcular_valor_esperado(partido.odds_visitante, prob_visitante)
        
        # IDENTIFICAR MEJOR APUESTA
        opciones = [
            ('local', valor_local, partido.odds_local, prob_local),
            ('empate', valor_empate, partido.odds_empate, prob_empate),
            ('visitante', valor_visitante, partido.odds_visitante, prob_visitante)
        ]
        mejor_opcion = max(opciones, key=lambda x: x[1])
        
        # CALCULAR CONFIANZA IA
        prob_max = max(prob_local, prob_empate, prob_visitante)
        diferencia_max = prob_max - (1/3)  # Diferencia vs equiprobabilidad
        confianza = 65 + (diferencia_max * 150)  # Base 65%, ajuste por certeza
        confianza = min(95, max(60, confianza))
        
        return {
            'probabilidad_local': round(prob_local * 100, 1),
            'probabilidad_empate': round(prob_empate * 100, 1),
            'probabilidad_visitante': round(prob_visitante * 100, 1),
            'valor_esperado_local': round(valor_local, 3),
            'valor_esperado_empate': round(valor_empate, 3),
            'valor_esperado_visitante': round(valor_visitante, 3),
            'mejor_apuesta': {
                'opcion': mejor_opcion[0],
                'valor_esperado': round(mejor_opcion[1], 3),
                'odds': mejor_opcion[2],
                'probabilidad': round(mejor_opcion[3] * 100, 1),
                'ganancia_potencial': f"{round((mejor_opcion[2] - 1) * 100, 1)}%"
            },
            'confianza_ia': round(confianza, 1),
            'factores_clave': {
                'puntos_promedio': f"Local: {puntos_casa} vs Visitante: {puntos_visita}",
                'eficiencia_neta': f"Local: {round(eficiencia_local, 3)} vs Visitante: {round(eficiencia_visitante, 3)}",
                'porcentaje_tiros': f"Local: {tiros_local}% vs Visitante: {tiros_visitante}%",
                'rebotes': f"Local: {stats['local']['rebotes_promedio']} vs Visitante: {stats['visitante']['rebotes_promedio']}"
            },
            'recomendacion_ia': self._generar_recomendacion(mejor_opcion, confianza)
        }

    def _analizar_tennis_avanzado(self, partido: Partido) -> Dict:
        """üéæ An√°lisis avanzado de tennis"""
        stats = partido.estadisticas
        
        # Factor ranking (muy importante en tennis)
        ranking_j1 = stats['jugador1']['ranking_atp']
        ranking_j2 = stats['jugador2']['ranking_atp']
        factor_ranking = (ranking_j2 - ranking_j1) / 50  # Normalizado
        
        # Factor forma actual
        victorias_j1 = stats['jugador1']['victorias_a√±o']
        total_j1 = victorias_j1 + stats['jugador1']['derrotas_a√±o']
        forma_j1 = victorias_j1 / total_j1 if total_j1 > 0 else 0.5
        
        victorias_j2 = stats['jugador2']['victorias_a√±o']
        total_j2 = victorias_j2 + stats['jugador2']['derrotas_a√±o']
        forma_j2 = victorias_j2 / total_j2 if total_j2 > 0 else 0.5
        
        factor_forma = (forma_j1 - forma_j2) * 0.3
        
        # Factor servicio
        saque_j1 = stats['jugador1']['porcentaje_primer_saque']
        saque_j2 = stats['jugador2']['porcentaje_primer_saque']
        factor_saque = (saque_j1 - saque_j2) / 100 * 0.25
        
        # Enfrentamientos directos
        h2h_j1 = stats['enfrentamientos_directos']['victorias_j1']
        h2h_j2 = stats['enfrentamientos_directos']['victorias_j2']
        total_h2h = h2h_j1 + h2h_j2
        factor_h2h = 0
        if total_h2h > 0:
            factor_h2h = ((h2h_j1 - h2h_j2) / total_h2h) * 0.15
        
        # Probabilidad final
        prob_j1 = 0.5 + factor_ranking + factor_forma + factor_saque + factor_h2h
        prob_j1 = max(0.1, min(0.9, prob_j1))
        prob_j2 = 1 - prob_j1
        
        # Valores esperados
        valor_j1 = self._calcular_valor_esperado(partido.odds_local, prob_j1)
        valor_j2 = self._calcular_valor_esperado(partido.odds_visitante, prob_j2)
        
        mejor_opcion = ('local', valor_j1, partido.odds_local, prob_j1) if valor_j1 > valor_j2 else ('visitante', valor_j2, partido.odds_visitante, prob_j2)
        
        # Confianza basada en diferencias
        diferencia_ranking = abs(ranking_j1 - ranking_j2)
        diferencia_forma = abs(forma_j1 - forma_j2)
        confianza = 75 + (diferencia_ranking / 50 * 15) + (diferencia_forma * 25)
        confianza = min(95, confianza)
        
        return {
            'probabilidad_local': round(prob_j1 * 100, 1),
            'probabilidad_visitante': round(prob_j2 * 100, 1),
            'valor_esperado_local': round(valor_j1, 3),
            'valor_esperado_visitante': round(valor_j2, 3),
            'mejor_apuesta': {
                'opcion': mejor_opcion[0],
                'valor_esperado': round(mejor_opcion[1], 3),
                'odds': mejor_opcion[2],
                'probabilidad': round(mejor_opcion[3] * 100, 1),
                'ganancia_potencial': f"{round((mejor_opcion[2] - 1) * 100, 1)}%"
            },
            'confianza_ia': round(confianza, 1),
            'factores_clave': {
                'ranking': f"#{ranking_j1} vs #{ranking_j2}",
                'forma_actual': f"{round(forma_j1*100, 1)}% vs {round(forma_j2*100, 1)}%",
                'primer_saque': f"{saque_j1}% vs {saque_j2}%",
                'enfrentamientos_directos': f"{h2h_j1}-{h2h_j2}" if total_h2h > 0 else "Sin historial"
            },
            'recomendacion_ia': self._generar_recomendacion(mejor_opcion, confianza)
        }

    def _analizar_generico(self, partido: Partido) -> Dict:
        """üîÑ An√°lisis gen√©rico para otros deportes"""
        # Usar odds como referencia base
        prob_local_mercado = 1 / partido.odds_local if partido.odds_local > 0 else 0.45
        prob_visitante_mercado = 1 / partido.odds_visitante if partido.odds_visitante > 0 else 0.45
        
        # Normalizar y aplicar ventaja local
        total_mercado = prob_local_mercado + prob_visitante_mercado
        if total_mercado > 0:
            prob_local = (prob_local_mercado / total_mercado) * 1.1  # +10% ventaja local
            prob_visitante = (prob_visitante_mercado / total_mercado) * 0.9
        else:
            prob_local = 0.55
            prob_visitante = 0.45
        
        # Renormalizar
        total = prob_local + prob_visitante
        prob_local /= total
        prob_visitante /= total
        
        valor_local = self._calcular_valor_esperado(partido.odds_local, prob_local)
        valor_visitante = self._calcular_valor_esperado(partido.odds_visitante, prob_visitante)
        
        mejor_opcion = ('local', valor_local, partido.odds_local, prob_local) if valor_local > valor_visitante else ('visitante', valor_visitante, partido.odds_visitante, prob_visitante)
        
        return {
            'probabilidad_local': round(prob_local * 100, 1),
            'probabilidad_visitante': round(prob_visitante * 100, 1),
            'valor_esperado_local': round(valor_local, 3),
            'valor_esperado_visitante': round(valor_visitante, 3),
            'mejor_apuesta': {
                'opcion': mejor_opcion[0],
                'valor_esperado': round(mejor_opcion[1], 3),
                'odds': mejor_opcion[2],
                'probabilidad': round(mejor_opcion[3] * 100, 1),
                'ganancia_potencial': f"{round((mejor_opcion[2] - 1) * 100, 1)}%"
            },
            'confianza_ia': 70.0,
            'factores_clave': {
                'base_analisis': 'Odds del mercado con ajuste por ventaja local',
                'odds_local': partido.odds_local,
                'odds_visitante': partido.odds_visitante
            },
            'recomendacion_ia': self._generar_recomendacion(mejor_opcion, 70)
        }

    def _calcular_forma(self, resultados: List[str]) -> float:
        """üìä Calcula forma reciente en porcentaje"""
        if not resultados:
            return 50.0
        puntos = {'V': 3, 'E': 1, 'D': 0}  # Victoria, Empate, Derrota
        total_puntos = sum(puntos.get(r, 0) for r in resultados)
        max_puntos = len(resultados) * 3
        return (total_puntos / max_puntos * 100) if max_puntos > 0 else 50.0

    def _calcular_valor_esperado(self, odds: float, probabilidad: float) -> float:
        """üí∞ Calcula el valor esperado de una apuesta"""
        if odds <= 0:
            return -1.0
        return (odds * probabilidad) - 1

    def _generar_recomendacion(self, mejor_opcion: tuple, confianza: float) -> str:
        """üí° Genera recomendaci√≥n textual inteligente"""
        opcion, valor, odds, prob = mejor_opcion
        
        if valor < 0.03:  # Menos de 3% de valor
            return f"‚ö†Ô∏è EVITAR - Valor insuficiente ({round(valor*100,1)}%)"
        elif valor < 0.05:  # Entre 3% y 5%
            return f"ü§î DUDOSO - Valor bajo ({round(valor*100,1)}%). Solo si tienes experiencia."
        elif valor < 0.10:  # Entre 5% y 10%
            return f"‚úÖ BUENA - Valor aceptable ({round(valor*100,1)}%). Apuesta recomendada."
        elif valor < 0.20:  # Entre 10% y 20%
            return f"üî• EXCELENTE - Alto valor ({round(valor*100,1)}%). ¬°Fuerte recomendaci√≥n!"
        else:  # M√°s de 20%
            return f"üíé EXCEPCIONAL - Valor extremo ({round(valor*100,1)}%). ¬°¬°M√°xima apuesta!!"

    def generar_reporte_inteligente(self) -> Dict:
        """üìä Genera reporte completo con las mejores oportunidades"""
        logger.info("üìä Generando reporte inteligente...")
        
        try:
            partidos = self.obtener_partidos_12h()
            analisis_completo = []
            
            for partido in partidos:
                try:
                    analisis = self.analizar_partido_ia(partido)
                    partido.prediccion = analisis
                    
                    analisis_completo.append({
                        'id': partido.id,
                        'partido': f"{partido.equipo_local} vs {partido.equipo_visitante}",
                        'liga': partido.liga,
                        'deporte': partido.deporte,
                        'fecha_hora': partido.fecha_hora.strftime('%Y-%m-%d %H:%M'),
                        'tiempo_restante': self._calcular_tiempo_restante(partido.fecha_hora),
                        'odds': {
                            'local': partido.odds_local,
                            'empate': partido.odds_empate if partido.odds_empate > 0 else None,
                            'visitante': partido.odds_visitante
                        },
                        'analisis_ia': analisis,
                        'es_oportunidad': analisis['mejor_apuesta']['valor_esperado'] > 0.05,  # M√≠nimo 5%
                        'nivel_riesgo': self._clasificar_riesgo(analisis)
                    })
                except Exception as e:
                    logger.error(f"Error analizando {partido.id}: {e}")
                    continue
            
            # Filtrar mejores oportunidades
            oportunidades = [a for a in analisis_completo if a['es_oportunidad']]
            oportunidades.sort(key=lambda x: x['analisis_ia']['mejor_apuesta']['valor_esperado'], reverse=True)
            
            # Estad√≠sticas generales
            total_partidos = len(analisis_completo)
            total_oportunidades = len(oportunidades)
            valor_promedio = np.mean([a['analisis_ia']['mejor_apuesta']['valor_esperado'] for a in oportunidades]) if oportunidades else 0
            confianza_promedio = np.mean([a['analisis_ia']['confianza_ia'] for a in analisis_completo])
            
            # Stats por deporte
            deportes_stats = {}
            for analisis in analisis_completo:
                deporte = analisis['deporte']
                if deporte not in deportes_stats:
                    deportes_stats[deporte] = {'total': 0, 'oportunidades': 0, 'mejor_valor': 0}
                deportes_stats[deporte]['total'] += 1
                if analisis['es_oportunidad']:
                    deportes_stats[deporte]['oportunidades'] += 1
                    valor_actual = analisis['analisis_ia']['mejor_apuesta']['valor_esperado']
                    if valor_actual > deportes_stats[deporte]['mejor_valor']:
                        deportes_stats[deporte]['mejor_valor'] = valor_actual
            
            self.ultimo_analisis = {
                'timestamp': datetime.now(TIMEZONE).isoformat(),
                'sistema': {
                    'version': 'IA Deportiva v4.0',
                    'horario_activo': self.es_horario_activo(),
                    'proxima_actualizacion': (datetime.now(TIMEZONE) + timedelta(hours=2)).strftime('%H:%M')
                },
                'resumen_ejecutivo': {
                    'total_partidos_analizados': total_partidos,
                    'oportunidades_detectadas': total_oportunidades,
                    'tasa_exito_deteccion': round((total_oportunidades/total_partidos*100) if total_partidos > 0 else 0, 1),
                    'valor_esperado_promedio': round(valor_promedio, 3),
                    'confianza_ia_promedio': round(confianza_promedio, 1),
                    'rentabilidad_potencial': f"+{round(valor_promedio*100, 1)}%" if valor_promedio > 0 else "0%"
                },
                'estadisticas_deportes': deportes_stats,
                'top_5_oportunidades': oportunidades[:5],
                'todas_las_oportunidades': oportunidades,
                'todos_los_analisis': analisis_completo,
                'criterios_ia': {
                    'valor_minimo_recomendado': '5.0%',
                    'confianza_minima': '60%',
                    'factores_analizados': ['Forma reciente', 'Rendimiento casa/visita', 'H2H', 'Estad√≠sticas ofensivas/defensivas', 'Condiciones especiales'],
                    'algoritmos_usados': ['An√°lisis cuantitativo', 'Pesos ponderados', 'Valor esperado', 'Gesti√≥n de riesgo']
                }
            }
            
            self.ultima_actualizacion = datetime.now(TIMEZONE)
            logger.info(f"‚úÖ Reporte generado: {total_oportunidades} oportunidades de {total_partidos} partidos")
            
            return self.ultimo_analisis
            
        except Exception as e:
            logger.error(f"‚ùå Error generando reporte: {e}")
            return {'error': str(e), 'timestamp': datetime.now(TIMEZONE).isoformat()}

    def _calcular_tiempo_restante(self, fecha_partido: datetime) -> str:
        """‚è∞ Calcula tiempo restante hasta el partido"""
        ahora = datetime.now(TIMEZONE)
        if fecha_partido.tzinfo is None:
            fecha_partido = TIMEZONE.localize(fecha_partido)
        
        diferencia = fecha_partido - ahora
        if diferencia.total_seconds() < 0:
            return "üî¥ YA COMENZ√ì"
        
        horas = int(diferencia.total_seconds() // 3600)
        minutos = int((diferencia.total_seconds() % 3600) // 60)
        
        if horas > 0:
            return f"‚è∞ {horas}h {minutos}min"
        else:
            return f"‚è∞ {minutos}min"

    def _clasificar_riesgo(self, analisis: Dict) -> str:
        """üéØ Clasifica nivel de riesgo de la apuesta"""
        valor_esperado = analisis['mejor_apuesta']['valor_esperado']
        confianza = analisis['confianza_ia']
        
        if valor_esperado > 0.15 and confianza > 85:
            return 'MUY BAJO'
        elif valor_esperado > 0.10 and confianza > 75:
            return 'BAJO'
        elif valor_esperado > 0.05 and confianza > 65:
            return 'MEDIO'
        else:
            return 'ALTO'

    def enviar_notificacion(self, mensaje: str, es_urgente: bool = False):
        """üì± Env√≠a notificaciones via webhook y Telegram"""
        try:
            timestamp_colombia = datetime.now(TIMEZONE).strftime('%d/%m/%Y %H:%M:%S')
            
            # Webhook (para N8N)
            if self.webhook_url:
                payload = {
                    'mensaje': mensaje,
                    'timestamp': timestamp_colombia,
                    'urgente': es_urgente,
                    'tipo': 'asistente_deportivo_ia',
                    'version': '4.0'
                }
                response = requests.post(self.webhook_url, json=payload, timeout=15)
                if response.status_code == 200:
                    logger.info("‚úÖ Notificaci√≥n webhook enviada exitosamente")
                else:
                    logger.warning(f"‚ö†Ô∏è Error webhook: HTTP {response.status_code}")
            
            # Telegram directo
            if self.telegram_token and self.telegram_chat_id:
                telegram_url = f"https://api.telegram.org/bot{self.telegram_token}/sendMessage"
                telegram_payload = {
                    'chat_id': self.telegram_chat_id,
                    'text': mensaje,
                    'parse_mode': 'HTML',
                    'disable_web_page_preview': True
                }
                response = requests.post(telegram_url, json=telegram_payload, timeout=15)
                if response.status_code == 200:
                    logger.info("‚úÖ Notificaci√≥n Telegram enviada exitosamente")
                else:
                    logger.warning(f"‚ö†Ô∏è Error Telegram: HTTP {response.status_code}")
                    
        except Exception as e:
            logger.error(f"‚ùå Error enviando notificaci√≥n: {e}")

    def generar_mensaje_oportunidades(self) -> str:
        """üí¨ Genera mensaje formateado con oportunidades"""
        if not self.ultimo_analisis:
            return "‚ùå No hay an√°lisis disponible"
        
        oportunidades = self.ultimo_analisis.get('top_5_oportunidades', [])
        
        if not oportunidades:
            resumen = self.ultimo_analisis['resumen_ejecutivo']
            return f"""üìä <b>AN√ÅLISIS COMPLETADO - SIN OPORTUNIDADES</b>

üîç Partidos analizados: {resumen['total_partidos_analizados']}
üìà Confianza IA promedio: {resumen['confianza_ia_promedio']}%

üí° <i>No se detectaron apuestas con valor superior al 5% m√≠nimo requerido.</i>

ü§ñ <b>IA Deportiva v4.0</b>
‚è∞ Pr√≥ximo an√°lisis: {self.ultimo_analisis['sistema']['proxima_actualizacion']}"""
        
        resumen = self.ultimo_analisis['resumen_ejecutivo']
        mensaje = f"""üéØ <b>¬°OPORTUNIDADES DETECTADAS!</b>

üìä <b>RESUMEN EJECUTIVO:</b>
‚Ä¢ Partidos analizados: {resumen['total_partidos_analizados']}
‚Ä¢ Oportunidades: {resumen['oportunidades_detectadas']}
‚Ä¢ Tasa de √©xito: {resumen['tasa_exito_deteccion']}%
‚Ä¢ Rentabilidad promedio: {resumen['rentabilidad_potencial']}

üî• <b>TOP {len(oportunidades)} MEJORES OPORTUNIDADES:</b>

"""
        
        for i, op in enumerate(oportunidades, 1):
            analisis = op['analisis_ia']
            mejor_apuesta = analisis['mejor_apuesta']
            
            # Emojis por deporte
            emoji_deporte = {
                'f√∫tbol': '‚öΩ', 'basketball': 'üèÄ', 'tennis': 'üéæ', 'b√©isbol': '‚öæ'
            }.get(op['deporte'], 'üèà')
            
            # Emoji por riesgo
            emoji_riesgo = {
                'MUY BAJO': 'üü¢', 'BAJO': 'üü¢', 'MEDIO': 'üü°', 'ALTO': 'üî¥'
            }.get(op['nivel_riesgo'], '‚ö™')
            
            # Determinar equipo recomendado
            if mejor_apuesta['opcion'] == 'local':
                equipo_rec = op['partido'].split(' vs ')[0]
            elif mejor_apuesta['opcion'] == 'empate':
                equipo_rec = "EMPATE"
            else:
                equipo_rec = op['partido'].split(' vs ')[1]
            
            mensaje += f"""<b>{i}. {emoji_deporte} {op['partido']}</b>
üèÜ {op['liga']}
{op['tiempo_restante']}

üí° <b>APOSTAR:</b> {equipo_rec}
üí∞ <b>Odds:</b> {mejor_apuesta['odds']} ({mejor_apuesta['ganancia_potencial']} ganancia)
üìà <b>Valor IA:</b> +{round(mejor_apuesta['valor_esperado']*100, 1)}%
üéØ <b>Probabilidad:</b> {mejor_apuesta['probabilidad']}%
üß† <b>Confianza:</b> {analisis['confianza_ia']}%
{emoji_riesgo} <b>Riesgo:</b> {op['nivel_riesgo']}

{analisis['recomendacion_ia']}

"""
        
        mensaje += f"""‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

ü§ñ <b>IA Deportiva v4.0</b> | An√°lisis Cuantitativo Avanzado
‚è∞ Pr√≥xima actualizaci√≥n: {self.ultimo_analisis['sistema']['proxima_actualizacion']}
üí¨ Sistema automatizado cada 2 horas"""
        
        return mensaje

# ============================================================================
# INSTANCIA GLOBAL Y FUNCIONES AUTOM√ÅTICAS
# ============================================================================

# Crear instancia global del asistente
asistente = AsistenteDeportivoIA()

def ejecutar_analisis_y_notificar():
    """üîÑ Funci√≥n principal que ejecuta an√°lisis y env√≠a notificaciones"""
    if not asistente.es_horario_activo():
        logger.info("‚è∞ Fuera de horario activo (7 AM - 12 AM). Sistema en pausa.")
        return
    
    try:
        logger.info("üöÄ Iniciando an√°lisis autom√°tico completo...")
        reporte = asistente.generar_reporte_inteligente()
        
        if 'error' in reporte:
            logger.error(f"‚ùå Error en an√°lisis: {reporte['error']}")
            asistente.enviar_notificacion("‚ö†Ô∏è Error en an√°lisis autom√°tico. Revisando sistema...", es_urgente=False)
            return
        
        # Enviar notificaci√≥n solo si hay oportunidades
        oportunidades = reporte['resumen_ejecutivo']['oportunidades_detectadas']
        if oportunidades > 0:
            mensaje = asistente.generar_mensaje_oportunidades()
            asistente.enviar_notificacion(mensaje, es_urgente=True)
            logger.info(f"üì± Notificaci√≥n URGENTE enviada: {oportunidades} oportunidades detectadas")
        else:
            # Notificaci√≥n informativa cada 6 horas si no hay oportunidades
            hora_actual = datetime.now(TIMEZONE).hour
            if hora_actual in [9, 15, 21]:  # 9 AM, 3 PM, 9 PM
                mensaje = asistente.generar_mensaje_oportunidades()
                asistente.enviar_notificacion(mensaje, es_urgente=False)
                logger.info("üìä Notificaci√≥n informativa enviada (sin oportunidades)")
            else:
                logger.info("üìä An√°lisis completado - Sin oportunidades de valor detectadas")
                
    except Exception as e:
        logger.error(f"‚ùå Error cr√≠tico en an√°lisis autom√°tico: {e}")
        asistente.enviar_notificacion(f"üö® ERROR CR√çTICO: {str(e)[:100]}...", es_urgente=True)

# Configurar programaci√≥n autom√°tica cada 2 horas
schedule.every(2).hours.do(ejecutar_analisis_y_notificar)

def ejecutar_scheduler():
    """‚öôÔ∏è Ejecuta el programador en hilo separado"""
    logger.info("‚öôÔ∏è Scheduler iniciado - An√°lisis cada 2 horas")
    while True:
        try:
            schedule.run_pending()
            time.sleep(60)  # Revisar cada minuto
        except Exception as e:
            logger.error(f"‚ùå Error en scheduler: {e}")
            time.sleep(300)  # Esperar 5 min si hay error

# Iniciar scheduler en hilo separado
scheduler_thread = threading.Thread(target=ejecutar_scheduler, daemon=True)
scheduler_thread.start()

# ============================================================================
# RUTAS FLASK - API WEB
# ============================================================================

@app.route('/')
def dashboard():
    """üè† Dashboard principal con interfaz visual avanzada"""
    global asistente
    
    # Asegurar que hay datos frescos
    if not asistente.ultimo_analisis:
        logger.info("üìä Generando primer an√°lisis para dashboard...")
        ejecutar_analisis_y_notificar()
    
    # Obtener datos para el dashboard
    ultima_act = asistente.ultima_actualizacion.strftime('%d/%m %H:%M') if asistente.ultima_actualizacion else 'Cargando...'
    datos = asistente.ultimo_analisis
    
    if datos and 'resumen_ejecutivo' in datos:
        resumen = datos['resumen_ejecutivo']
        sistema = datos['sistema']
        oportunidades = datos.get('top_5_oportunidades', [])[:3]  # Solo top 3 para dashboard
    else:
        # Datos por defecto si no hay an√°lisis
        resumen = {
            'total_partidos_analizados': 0,
            'oportunidades_detectadas': 0,
            'tasa_exito_deteccion': 0,
            'valor_esperado_promedio': 0,
            'confianza_ia_promedio': 0,
            'rentabilidad_potencial': '0%'
        }
        sistema = {
            'version': 'IA Deportiva v4.0',
            'horario_activo': asistente.es_horario_activo(),
            'hora_actual_colombia': ahora.strftime('%d/%m/%Y %H:%M:%S'),
            'tiempo_funcionando_minutos': round(tiempo_funcionando / 60, 1),
            'ultima_actualizacion': asistente.ultima_actualizacion.isoformat() if asistente.ultima_actualizacion else None
        },
        'configuracion': {
            'horario_operacion': '07:00 - 24:00 (GMT-5 Colombia)',
            'frecuencia_analisis': 'Cada 2 horas autom√°tico',
            'valor_minimo_recomendacion': '5.0%',
            'confianza_minima_ia': '60%',
            'deportes_soportados': ['F√∫tbol', 'Basketball', 'Tennis', 'B√©isbol'],
            'webhook_configurado': bool(asistente.webhook_url),
            'telegram_configurado': bool(asistente.telegram_token and asistente.telegram_chat_id)
        },
        'estadisticas_sesion': {
            'partidos_ultimo_analisis': asistente.ultimo_analisis['resumen_ejecutivo']['total_partidos_analizados'] if asistente.ultimo_analisis and 'resumen_ejecutivo' in asistente.ultimo_analisis else 0,
            'oportunidades_detectadas': asistente.ultimo_analisis['resumen_ejecutivo']['oportunidades_detectadas'] if asistente.ultimo_analisis and 'resumen_ejecutivo' in asistente.ultimo_analisis else 0,
            'confianza_promedio': asistente.ultimo_analisis['resumen_ejecutivo']['confianza_ia_promedio'] if asistente.ultimo_analisis and 'resumen_ejecutivo' in asistente.ultimo_analisis else 0,
            'rentabilidad_potencial': asistente.ultimo_analisis['resumen_ejecutivo']['rentabilidad_potencial'] if asistente.ultimo_analisis and 'resumen_ejecutivo' in asistente.ultimo_analisis else '0%'
        },
        'endpoints_disponibles': [
            'GET / - Dashboard principal',
            'GET /api/analisis - An√°lisis completo JSON',
            'GET /api/oportunidades - Solo oportunidades',
            'GET /api/deporte/{deporte} - Filtrar por deporte',
            'POST /api/forzar - An√°lisis manual',
            'GET /health - Estado sistema',
            'POST /api/configurar - Configurar notificaciones'
        ]
    })

@app.route('/api/configurar', methods=['POST'])
def api_configurar():
    """‚öôÔ∏è Configurar webhooks y notificaciones"""
    global asistente
    
    try:
        data = request.get_json()
        cambios = []
        
        if 'webhook_url' in data:
            asistente.webhook_url = data['webhook_url']
            cambios.append('webhook_url')
            
        if 'telegram_token' in data:
            asistente.telegram_token = data['telegram_token']
            cambios.append('telegram_token')
            
        if 'telegram_chat_id' in data:
            asistente.telegram_chat_id = data['telegram_chat_id']
            cambios.append('telegram_chat_id')
        
        # Guardar en variables de entorno si es posible
        if 'webhook_url' in data:
            os.environ['WEBHOOK_URL'] = data['webhook_url']
        if 'telegram_token' in data:
            os.environ['TELEGRAM_TOKEN'] = data['telegram_token']
        if 'telegram_chat_id' in data:
            os.environ['TELEGRAM_CHAT_ID'] = data['telegram_chat_id']
        
        return jsonify({
            'status': 'success',
            'message': 'Configuraci√≥n actualizada exitosamente',
            'timestamp': datetime.now(TIMEZONE).isoformat(),
            'cambios_realizados': cambios,
            'configuracion_actual': {
                'webhook_configurado': bool(asistente.webhook_url),
                'telegram_configurado': bool(asistente.telegram_token and asistente.telegram_chat_id),
                'notificaciones_activas': bool(asistente.webhook_url or (asistente.telegram_token and asistente.telegram_chat_id))
            }
        })
    except Exception as e:
        return jsonify({
            'status': 'error',
            'message': f'Error actualizando configuraci√≥n: {str(e)}',
            'timestamp': datetime.now(TIMEZONE).isoformat()
        }), 500

@app.route('/api/test-notificacion', methods=['POST'])
def api_test_notificacion():
    """üß™ Probar sistema de notificaciones"""
    try:
        mensaje_test = f"""üß™ <b>PRUEBA DEL SISTEMA</b>

‚úÖ Sistema funcionando correctamente
üïê {datetime.now(TIMEZONE).strftime('%d/%m/%Y %H:%M:%S')}
ü§ñ Asistente IA Deportiva v4.0

Este es un mensaje de prueba para verificar que las notificaciones est√°n funcionando."""
        
        asistente.enviar_notificacion(mensaje_test, es_urgente=False)
        
        return jsonify({
            'status': 'success',
            'message': 'Notificaci√≥n de prueba enviada',
            'timestamp': datetime.now(TIMEZONE).isoformat(),
            'configuracion': {
                'webhook_configurado': bool(asistente.webhook_url),
                'telegram_configurado': bool(asistente.telegram_token and asistente.telegram_chat_id)
            }
        })
    except Exception as e:
        return jsonify({
            'status': 'error',
            'message': f'Error enviando notificaci√≥n de prueba: {str(e)}',
            'timestamp': datetime.now(TIMEZONE).isoformat()
        }), 500

# ============================================================================
# MANEJADORES DE ERRORES
# ============================================================================

@app.errorhandler(404)
def not_found(error):
    return jsonify({
        'status': 'error',
        'message': 'Endpoint no encontrado',
        'timestamp': datetime.now(TIMEZONE).isoformat(),
        'endpoints_disponibles': [
            'GET /', 'GET /api/analisis', 'GET /api/oportunidades',
            'GET /api/deporte/{deporte}', 'POST /api/forzar', 'GET /health',
            'POST /api/configurar', 'POST /api/test-notificacion'
        ]
    }), 404

@app.errorhandler(500)
def server_error(error):
    logger.error(f"‚ùå Error interno del servidor: {error}")
    return jsonify({
        'status': 'error',
        'message': 'Error interno del servidor',
        'timestamp': datetime.now(TIMEZONE).isoformat(),
        'solucion': 'Intente nuevamente en unos momentos'
    }), 500

@app.errorhandler(503)
def service_unavailable(error):
    return jsonify({
        'status': 'error',
        'message': 'Servicio temporalmente no disponible',
        'timestamp': datetime.now(TIMEZONE).isoformat(),
        'razon': 'Sistema inicializ√°ndose o fuera de horario'
    }), 503

# ============================================================================
# INICIALIZACI√ìN Y PUNTO DE ENTRADA PRINCIPAL
# ============================================================================

# Ejecutar primer an√°lisis al iniciar la aplicaci√≥n
logger.info("üöÄ Iniciando sistema...")
logger.info("üìä Ejecutando primer an√°lisis...")

try:
    ejecutar_analisis_y_notificar()
    logger.info("‚úÖ Primer an√°lisis completado exitosamente")
except Exception as e:
    logger.error(f"‚ùå Error en primer an√°lisis: {e}")

# Punto de entrada principal
if __name__ == '__main__':
    logger.info("=" * 70)
    logger.info("üéØ ASISTENTE IA DEPORTIVA v4.0 - SISTEMA INICIADO")
    logger.info("=" * 70)
    logger.info("")
    logger.info("‚ö° CARACTER√çSTICAS PRINCIPALES:")
    logger.info("   ‚Ä¢ üîÑ An√°lisis autom√°tico cada 2 horas")
    logger.info("   ‚Ä¢ ‚è∞ Horario inteligente (7 AM - 12 AM Colombia)")
    logger.info("   ‚Ä¢ üì± Notificaciones autom√°ticas (Webhook + Telegram)")
    logger.info("   ‚Ä¢ üåê Dashboard web interactivo en tiempo real")
    logger.info("   ‚Ä¢ üîå API REST completa para integraci√≥n")
    logger.info("   ‚Ä¢ üèÜ Soporte multi-deporte (F√∫tbol, Basketball, Tennis, B√©isbol)")
    logger.info("   ‚Ä¢ üß† Algoritmos avanzados de Machine Learning")
    logger.info("   ‚Ä¢ üí∞ An√°lisis de valor esperado y gesti√≥n de riesgo")
    logger.info("")
    logger.info("üîó CONFIGURACI√ìN:")
    logger.info(f"   ‚Ä¢ Webhook URL: {'‚úÖ Configurado' if asistente.webhook_url else '‚ùå No configurado'}")
    logger.info(f"   ‚Ä¢ Telegram Bot: {'‚úÖ Configurado' if asistente.telegram_token else '‚ùå No configurado'}")
    logger.info(f"   ‚Ä¢ Telegram Chat: {'‚úÖ Configurado' if asistente.telegram_chat_id else '‚ùå No configurado'}")
    logger.info("")
    logger.info("üìä CRITERIOS IA:")
    logger.info("   ‚Ä¢ Valor esperado m√≠nimo: 5%")
    logger.info("   ‚Ä¢ Confianza IA m√≠nima: 60%")
    logger.info("   ‚Ä¢ Gesti√≥n autom√°tica de riesgo")
    logger.info("   ‚Ä¢ Notificaciones inteligentes")
    logger.info("")
    
    # Puerto para Render y otros servicios cloud
    PORT = int(os.environ.get('PORT', 5000))
    
    logger.info(f"üåê Servidor iniciando en puerto {PORT}")
    logger.info("üéØ ¬°Sistema listo para an√°lisis deportivo profesional!")
    logger.info("=" * 70)
    
    # Ejecutar aplicaci√≥n Flask
    app.run(
        host='0.0.0.0', 
        port=PORT, 
        debug=False, 
        threaded=True,
        use_reloader=False  # Evitar problemas con el scheduler
    )
            'proxima_actualizacion': '...'
        }
        oportunidades = []
    
    html_template = f"""
    <!DOCTYPE html>
    <html lang="es">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>üéØ Asistente IA Deportiva v4.0 - Dashboard</title>
        <meta http-equiv="refresh" content="60">
        
        <style>
            * {{ margin: 0; padding: 0; box-sizing: border-box; }}
            
            body {{
                background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 25%, #16213e 50%, #2d1b69 100%);
                color: white;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
                line-height: 1.6;
                min-height: 100vh;
                overflow-x: hidden;
            }}
            
            .container {{ 
                max-width: 1400px; 
                margin: 0 auto; 
                padding: 20px; 
                position: relative;
                z-index: 10;
            }}
            
            /* Efectos de fondo animados */
            .bg-effects {{
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 1;
            }}
            
            .bg-effects::before {{
                content: '';
                position: absolute;
                top: 20%;
                left: 10%;
                width: 300px;
                height: 300px;
                background: radial-gradient(circle, rgba(0,255,136,0.1) 0%, transparent 70%);
                border-radius: 50%;
                animation: float1 8s ease-in-out infinite;
            }}
            
            .bg-effects::after {{
                content: '';
                position: absolute;
                bottom: 20%;
                right: 15%;
                width: 250px;
                height: 250px;
                background: radial-gradient(circle, rgba(255,107,53,0.1) 0%, transparent 70%);
                border-radius: 50%;
                animation: float2 10s ease-in-out infinite reverse;
            }}
            
            @keyframes float1 {{
                0%, 100% {{ transform: translateY(0px) rotate(0deg); opacity: 0.3; }}
                50% {{ transform: translateY(-30px) rotate(180deg); opacity: 0.6; }}
            }}
            
            @keyframes float2 {{
                0%, 100% {{ transform: translateY(0px) rotate(0deg); opacity: 0.4; }}
                50% {{ transform: translateY(20px) rotate(-180deg); opacity: 0.8; }}
            }}
            
            .header {{
                background: linear-gradient(135deg, #ff6b35 0%, #f7931e 50%, #00ff88 100%);
                padding: 40px;
                border-radius: 25px;
                text-align: center;
                margin-bottom: 40px;
                box-shadow: 0 20px 60px rgba(255, 107, 53, 0.4);
                position: relative;
                overflow: hidden;
                animation: pulse-header 4s ease-in-out infinite;
            }}
            
            .header::before {{
                content: '';
                position: absolute;
                top: -50%;
                left: -50%;
                width: 200%;
                height: 200%;
                background: conic-gradient(transparent, rgba(255,255,255,0.1), transparent);
                animation: rotate-bg 20s linear infinite;
            }}
            
            @keyframes pulse-header {{
                0%, 100% {{ transform: scale(1); box-shadow: 0 20px 60px rgba(255, 107, 53, 0.4); }}
                50% {{ transform: scale(1.02); box-shadow: 0 25px 80px rgba(255, 107, 53, 0.6); }}
            }}
            
            @keyframes rotate-bg {{
                0% {{ transform: rotate(0deg); }}
                100% {{ transform: rotate(360deg); }}
            }}
            
            .header h1 {{ 
                font-size: 3.2em; 
                margin-bottom: 15px; 
                text-shadow: 3px 3px 6px rgba(0,0,0,0.5); 
                font-weight: 900; 
                position: relative;
                z-index: 2;
                background: linear-gradient(45deg, #fff, #f0f0f0);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
            }}
            
            .header p {{
                font-size: 1.3em;
                margin: 8px 0;
                position: relative;
                z-index: 2;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            }}
            
            .status-indicator {{
                display: inline-flex;
                align-items: center;
                gap: 10px;
                background: rgba(0,0,0,0.3);
                padding: 12px 20px;
                border-radius: 50px;
                margin-top: 15px;
                position: relative;
                z-index: 2;
            }}
            
            .status-dot {{
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background: #00ff88;
                animation: pulse-dot 2s infinite;
            }}
            
            @keyframes pulse-dot {{
                0%, 100% {{ opacity: 1; transform: scale(1); }}
                50% {{ opacity: 0.6; transform: scale(1.2); }}
            }}
            
            .stats-grid {{
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 25px;
                margin: 40px 0;
            }}
            
            .stat-card {{
                background: rgba(22, 33, 62, 0.95);
                backdrop-filter: blur(20px);
                border: 1px solid rgba(255,255,255,0.1);
                padding: 30px;
                border-radius: 20px;
                text-align: center;
                position: relative;
                transition: all 0.4s cubic-bezier(0.23, 1, 0.320, 1);
                overflow: hidden;
                cursor: pointer;
            }}
            
            .stat-card::before {{
                content: '';
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(90deg, transparent, rgba(0,255,136,0.15), transparent);
                transition: left 0.6s;
            }}
            
            .stat-card:hover {{
                transform: translateY(-10px) scale(1.03);
                border-color: #00ff88;
                box-shadow: 0 25px 50px rgba(0, 255, 136, 0.3);
            }}
            
            .stat-card:hover::before {{
                left: 100%;
            }}
            
            .stat-title {{ 
                font-size: 1.1em; 
                opacity: 0.9; 
                margin-bottom: 20px; 
                text-transform: uppercase;
                letter-spacing: 2px;
                font-weight: 600;
            }}
            
            .stat-value {{ 
                font-size: 3.2em; 
                font-weight: 900; 
                margin: 20px 0; 
                background: linear-gradient(135deg, #00ff88, #4fc3f7, #ff6b35);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                text-shadow: none;
                animation: gradient-shift 3s ease-in-out infinite;
            }}
            
            @keyframes gradient-shift {{
                0%, 100% {{ background-position: 0% 50%; }}
                50% {{ background-position: 100% 50%; }}
            }}
            
            .stat-subtitle {{
                font-size: 0.9em;
                opacity: 0.7;
                margin-top: 10px;
            }}
            
            .opportunities {{
                background: rgba(22, 33, 62, 0.9);
                backdrop-filter: blur(25px);
                border: 1px solid rgba(0, 255, 136, 0.3);
                padding: 40px;
                border-radius: 25px;
                margin: 40px 0;
                position: relative;
                overflow: hidden;
            }}
            
            .opportunities::before {{
                content: '';
                position: absolute;
                top: -2px;
                left: -2px;
                right: -2px;
                bottom: -2px;
                background: linear-gradient(45deg, #00ff88, #4fc3f7, #ff6b35, #00ff88);
                border-radius: 25px;
                z-index: -1;
                animation: border-glow 4s linear infinite;
            }}
            
            @keyframes border-glow {{
                0% {{ background-position: 0% 50%; }}
                100% {{ background-position: 200% 50%; }}
            }}
            
            .opportunities h3 {{ 
                color: #00ff88; 
                margin-bottom: 30px; 
                font-size: 2.2em; 
                text-align: center;
                text-transform: uppercase;
                letter-spacing: 3px;
                font-weight: 800;
            }}
            
            .opportunity-item {{
                background: linear-gradient(135deg, rgba(15, 15, 35, 0.8), rgba(22, 33, 62, 0.9));
                backdrop-filter: blur(15px);
                padding: 30px;
                margin: 25px 0;
                border-radius: 20px;
                border-left: 6px solid #00ff88;
                transition: all 0.4s cubic-bezier(0.23, 1, 0.320, 1);
                position: relative;
                overflow: hidden;
            }}
            
            .opportunity-item::before {{
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                width: 0%;
                height: 100%;
                background: linear-gradient(90deg, rgba(0,255,136,0.1), rgba(0,255,136,0.05));
                transition: width 0.6s ease;
            }}
            
            .opportunity-item:hover {{
                transform: translateX(10px) scale(1.02);
                border-left-color: #4fc3f7;
                box-shadow: 0 15px 40px rgba(0, 255, 136, 0.2);
            }}
            
            .opportunity-item:hover::before {{
                width: 100%;
            }}
            
            .match-header {{ 
                font-size: 1.6em; 
                font-weight: 800; 
                color: #4fc3f7; 
                margin-bottom: 15px;
                display: flex;
                align-items: center;
                gap: 15px;
                position: relative;
                z-index: 2;
            }}
            
            .league-badge {{
                background: linear-gradient(45deg, #ff6b35, #f7931e);
                padding: 4px 12px;
                border-radius: 20px;
                font-size: 0.6em;
                text-transform: uppercase;
                letter-spacing: 1px;
                font-weight: 600;
            }}
            
            .recommendation {{ 
                font-size: 1.4em; 
                color: #00ff88; 
                margin: 15px 0; 
                font-weight: 800;
                text-transform: uppercase;
                position: relative;
                z-index: 2;
            }}
            
            .details {{ 
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
                gap: 15px;
                margin-top: 20px;
                position: relative;
                z-index: 2;
            }}
            
            .detail-item {{
                background: rgba(0, 0, 0, 0.4);
                backdrop-filter: blur(10px);
                padding: 12px 16px;
                border-radius: 12px;
                border-left: 4px solid #4fc3f7;
                transition: all 0.3s ease;
                font-size: 0.95em;
            }}
            
            .detail-item:hover {{
                background: rgba(0, 0, 0, 0.6);
                border-left-color: #00ff88;
                transform: translateY(-2px);
            }}
            
            .risk-indicator {{
                position: absolute;
                top: 20px;
                right: 20px;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                animation: pulse-risk 3s infinite;
                z-index: 3;
            }}
            
            .risk-muy-bajo, .risk-bajo {{ background: #00ff88; }}
            .risk-medio {{ background: #ffa726; }}
            .risk-alto {{ background: #ff5252; }}
            
            @keyframes pulse-risk {{
                0%, 100% {{ opacity: 1; transform: scale(1); }}
                50% {{ opacity: 0.4; transform: scale(1.3); }}
            }}
            
            .no-opportunities {{
                text-align: center;
                padding: 50px;
                background: rgba(255, 165, 0, 0.1);
                border-radius: 20px;
                border: 2px dashed #ffa726;
            }}
            
            .no-opportunities h4 {{
                font-size: 1.5em;
                color: #ffa726;
                margin-bottom: 15px;
            }}
            
            .system-info {{
                background: rgba(22, 33, 62, 0.8);
                backdrop-filter: blur(20px);
                border: 1px solid rgba(255,255,255,0.1);
                padding: 30px;
                border-radius: 20px;
                margin-top: 50px;
                text-align: center;
            }}
            
            .system-info h3 {{
                color: #4fc3f7;
                font-size: 1.8em;
                margin-bottom: 25px;
                font-weight: 700;
            }}
            
            .api-endpoints {{
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: 15px;
                margin: 25px 0;
            }}
            
            .endpoint {{
                background: rgba(0, 0, 0, 0.4);
                backdrop-filter: blur(10px);
                padding: 15px;
                border-radius: 12px;
                font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                font-size: 0.9em;
                border-left: 4px solid #4fc3f7;
                transition: all 0.3s ease;
            }}
            
            .endpoint:hover {{
                background: rgba(0, 0, 0, 0.6);
                border-left-color: #00ff88;
                transform: translateY(-2px);
            }}
            
            .footer-info {{
                margin-top: 30px;
                padding: 25px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 15px;
                border: 1px solid rgba(255,255,255,0.05);
            }}
            
            .footer-info p {{
                margin: 8px 0;
                opacity: 0.9;
            }}
            
            .highlight {{
                color: #00ff88;
                font-weight: 600;
            }}
            
            /* Responsive */
            @media (max-width: 768px) {{
                .container {{ padding: 15px; }}
                .header h1 {{ font-size: 2.4em; }}
                .header p {{ font-size: 1.1em; }}
                .stat-value {{ font-size: 2.4em; }}
                .match-header {{ font-size: 1.3em; flex-direction: column; align-items: flex-start; }}
                .details {{ grid-template-columns: 1fr; }}
                .opportunities {{ padding: 25px; }}
                .stats-grid {{ grid-template-columns: 1fr; gap: 20px; }}
            }}
        </style>
    </head>
    <body>
        <div class="bg-effects"></div>
        
        <div class="container">
            <div class="header">
                <h1>üéØ ASISTENTE IA DEPORTIVA v4.0</h1>
                <p>ü§ñ <strong>Sistema de Inteligencia Artificial Cuantitativa</strong></p>
                <p>‚ö° An√°lisis Predictivo Avanzado con Machine Learning</p>
                <p>üìä Actualizaciones Autom√°ticas cada 2 horas (7 AM - 12 AM)</p>
                
                <div class="status-indicator">
                    <div class="status-dot"></div>
                    <span><strong>SISTEMA {'üü¢ ACTIVO' if sistema['horario_activo'] else 'üî¥ EN PAUSA'}</strong></span>
                </div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-title">üìä PARTIDOS ANALIZADOS</div>
                    <div class="stat-value">{resumen['total_partidos_analizados']}</div>
                    <div class="stat-subtitle">√öltima actualizaci√≥n: {ultima_act}</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-title">üíé OPORTUNIDADES</div>
                    <div class="stat-value">{resumen['oportunidades_detectadas']}</div>
                    <div class="stat-subtitle">Tasa de detecci√≥n: {resumen['tasa_exito_deteccion']}%</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-title">üìà RENTABILIDAD PROMEDIO</div>
                    <div class="stat-value">{resumen['rentabilidad_potencial']}</div>
                    <div class="stat-subtitle">Valor esperado positivo</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-title">üß† CONFIANZA IA</div>
                    <div class="stat-value">{resumen['confianza_ia_promedio']}%</div>
                    <div class="stat-subtitle">Algoritmos avanzados</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-title">‚ö° SISTEMA</div>
                    <div class="stat-value" style="font-size: 2em;">{'ACTIVO' if sistema['horario_activo'] else 'PAUSA'}</div>
                    <div class="stat-subtitle">Pr√≥xima: {sistema['proxima_actualizacion']}</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-title">üîÑ VERSI√ìN</div>
                    <div class="stat-value" style="font-size: 1.8em;">v4.0</div>
                    <div class="stat-subtitle">√öltima versi√≥n estable</div>
                </div>
            </div>
    """
    
    # Agregar secci√≥n de oportunidades
    if oportunidades:
        html_template += f"""
            <div class="opportunities">
                <h3>üöÄ TOP OPORTUNIDADES DETECTADAS</h3>
        """
        
        for i, op in enumerate(oportunidades, 1):
            analisis = op['analisis_ia']
            mejor_apuesta = analisis['mejor_apuesta']
            
            # Emojis seg√∫n el deporte
            emoji_deporte = {
                'f√∫tbol': '‚öΩ', 'basketball': 'üèÄ', 'tennis': 'üéæ', 'b√©isbol': '‚öæ'
            }.get(op['deporte'], 'üèà')
            
            # Determinar equipo recomendado
            if mejor_apuesta['opcion'] == 'local':
                equipo_rec = op['partido'].split(' vs ')[0]
            elif mejor_apuesta['opcion'] == 'empate':
                equipo_rec = "EMPATE"
            else:
                equipo_rec = op['partido'].split(' vs ')[1]
            
            html_template += f"""
                <div class="opportunity-item">
                    <div class="risk-indicator risk-{op['nivel_riesgo'].lower().replace(' ', '-')}"></div>
                    
                    <div class="match-header">
                        {emoji_deporte} <strong>{op['partido']}</strong>
                        <span class="league-badge">{op['liga']}</span>
                    </div>
                    
                    <div class="recommendation">
                        üí° APOSTAR: {equipo_rec}
                    </div>
                    
                    <div class="details">
                        <div class="detail-item">
                            <strong>üí∞ Odds:</strong> {mejor_apuesta['odds']}
                        </div>
                        <div class="detail-item">
                            <strong>üìà Valor IA:</strong> +{round(mejor_apuesta['valor_esperado']*100, 1)}%
                        </div>
                        <div class="detail-item">
                            <strong>üéØ Probabilidad:</strong> {mejor_apuesta['probabilidad']}%
                        </div>
                        <div class="detail-item">
                            <strong>üß† Confianza:</strong> {analisis['confianza_ia']}%
                        </div>
                        <div class="detail-item">
                            <strong>‚è∞ Tiempo:</strong> {op['tiempo_restante']}
                        </div>
                        <div class="detail-item">
                            <strong>üé≤ Riesgo:</strong> {op['nivel_riesgo']}
                        </div>
                        <div class="detail-item" style="grid-column: 1 / -1;">
                            <strong>üí¨ Recomendaci√≥n IA:</strong> {analisis['recomendacion_ia']}
                        </div>
                    </div>
                </div>
            """
        
        html_template += "</div>"
    else:
        html_template += """
            <div class="opportunities">
                <h3>üìä ESTADO ACTUAL DEL AN√ÅLISIS</h3>
                <div class="no-opportunities">
                    <h4>üîç Sin oportunidades de alto valor detectadas</h4>
                    <p>El sistema analiz√≥ todos los partidos disponibles y no encontr√≥ apuestas con valor esperado superior al <span class="highlight">5% m√≠nimo requerido</span>.</p>
                    <p style="margin-top: 15px;">‚è∞ <strong>Pr√≥ximo an√°lisis autom√°tico:</strong> """ + sistema['proxima_actualizacion'] + """</p>
                </div>
            </div>
        """
    
    # Completar el HTML
    html_template += """
            <div class="system-info">
                <h3>üì° INFORMACI√ìN DEL SISTEMA</h3>
                
                <div class="api-endpoints">
                    <div class="endpoint"><strong>GET /</strong><br>Dashboard principal interactivo</div>
                    <div class="endpoint"><strong>GET /api/analisis</strong><br>An√°lisis completo en JSON</div>
                    <div class="endpoint"><strong>GET /api/oportunidades</strong><br>Solo mejores oportunidades</div>
                    <div class="endpoint"><strong>GET /api/deporte/{deporte}</strong><br>Filtrar por deporte espec√≠fico</div>
                    <div class="endpoint"><strong>POST /api/forzar</strong><br>Ejecutar an√°lisis manual</div>
                    <div class="endpoint"><strong>GET /health</strong><br>Estado del sistema completo</div>
                </div>
                
                <div class="footer-info">
                    <p><span class="highlight">üî¨ ALGORITMOS IA:</span> An√°lisis cuantitativo con forma reciente, rendimiento casa/visita, enfrentamientos directos, estad√≠sticas ofensivas/defensivas</p>
                    <p><span class="highlight">‚ö° AUTOMATIZACI√ìN:</span> Sistema ejecuta an√°lisis cada 2 horas con notificaciones autom√°ticas inteligentes</p>
                    <p><span class="highlight">üéØ CRITERIOS:</span> Valor esperado m√≠nimo 5%, confianza IA m√≠nima 60%, gesti√≥n de riesgo avanzada</p>
                    <p><span class="highlight">üèÜ DEPORTES:</span> F√∫tbol, Basketball, Tennis, B√©isbol con expansi√≥n continua</p>
                    <p><span class="highlight">üì± NOTIFICACIONES:</span> Webhook para N8N + Telegram directo con mensajes personalizados</p>
                </div>
            </div>
        </div>
        
        <script>
            // Auto-refresh inteligente
            setTimeout(function() {{
                if (document.visibilityState === 'visible') {{
                    window.location.reload();
                }}
            }}, 60000);
            
            // Efectos visuales adicionales
            document.querySelectorAll('.stat-card').forEach((card, index) => {{
                card.style.animationDelay = (index * 0.1) + 's';
                card.style.animation = 'slideInUp 0.6s ease-out forwards';
            }});
            
            // Animaci√≥n de entrada
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideInUp {{
                    from {{
                        opacity: 0;
                        transform: translateY(30px);
                    }}
                    to {{
                        opacity: 1;
                        transform: translateY(0);
                    }}
                }}
            `;
            document.head.appendChild(style);
        </script>
    </body>
    </html>
    """
    
    return html_template

@app.route('/api/analisis')
def api_analisis():
    """üìä API completa del an√°lisis en formato JSON"""
    global asistente
    
    if not asistente.ultimo_analisis:
        logger.info("üìä Ejecutando an√°lisis para API...")
        ejecutar_analisis_y_notificar()
    
    return jsonify({
        'status': 'success',
        'timestamp': datetime.now(TIMEZONE).isoformat(),
        'data': asistente.ultimo_analisis,
        'sistema': {
            'version': '4.0',
            'horario_activo': asistente.es_horario_activo(),
            'ultima_actualizacion': asistente.ultima_actualizacion.isoformat() if asistente.ultima_actualizacion else None
        }
    })

@app.route('/api/oportunidades')
def api_oportunidades():
    """üíé API solo con las mejores oportunidades"""
    global asistente
    
    if not asistente.ultimo_analisis:
        return jsonify({
            'status': 'error', 
            'message': 'Sistema inicializando. Intente en unos segundos.',
            'timestamp': datetime.now(TIMEZONE).isoformat()
        }), 503
    
    oportunidades = asistente.ultimo_analisis.get('top_5_oportunidades', [])
    todas_oportunidades = asistente.ultimo_analisis.get('todas_las_oportunidades', [])
    
    return jsonify({
        'status': 'success',
        'timestamp': datetime.now(TIMEZONE).isoformat(),
        'resumen': {
            'total_oportunidades': len(todas_oportunidades),
            'top_5': len(oportunidades),
            'criterio_minimo': '5% valor esperado',
            'confianza_minima': '60%'
        },
        'top_5_oportunidades': oportunidades,
        'todas_las_oportunidades': todas_oportunidades,
        'sistema': asistente.ultimo_analisis.get('sistema', {})
    })

@app.route('/api/deporte/<deporte>')
def api_por_deporte(deporte):
    """üèÄ API filtrada por deporte espec√≠fico"""
    global asistente
    
    if not asistente.ultimo_analisis:
        return jsonify({
            'status': 'error', 
            'message': 'Sin datos disponibles. Sistema inicializando.'
        }), 503
    
    todos_analisis = asistente.ultimo_analisis.get('todos_los_analisis', [])
    filtrado = [a for a in todos_analisis if a['deporte'].lower() == deporte.lower()]
    
    if not filtrado:
        deportes_disponibles = list(set(a['deporte'] for a in todos_analisis))
        return jsonify({
            'status': 'error',
            'message': f'Deporte "{deporte}" no encontrado',
            'deportes_disponibles': deportes_disponibles,
            'timestamp': datetime.now(TIMEZONE).isoformat()
        }), 404
    
    oportunidades_deporte = [a for a in filtrado if a['es_oportunidad']]
    
    # Estad√≠sticas del deporte
    valores = [a['analisis_ia']['mejor_apuesta']['valor_esperado'] for a in oportunidades_deporte]
    valor_promedio = np.mean(valores) if valores else 0
    valor_maximo = max(valores) if valores else 0
    
    return jsonify({
        'status': 'success',
        'timestamp': datetime.now(TIMEZONE).isoformat(),
        'deporte': deporte.title(),
        'estadisticas': {
            'total_partidos': len(filtrado),
            'oportunidades': len(oportunidades_deporte),
            'tasa_oportunidades': round((len(oportunidades_deporte)/len(filtrado)*100) if len(filtrado) > 0 else 0, 1),
            'valor_promedio': round(valor_promedio, 3),
            'mejor_valor': round(valor_maximo, 3)
        },
        'todos_los_partidos': filtrado,
        'mejores_oportunidades': sorted(oportunidades_deporte, 
                                      key=lambda x: x['analisis_ia']['mejor_apuesta']['valor_esperado'], 
                                      reverse=True)
    })

@app.route('/api/forzar', methods=['POST'])
def api_forzar_analisis():
    """üîÑ Fuerza an√°lisis manual inmediato"""
    try:
        logger.info("üîÑ An√°lisis manual forzado via API")
        ejecutar_analisis_y_notificar()
        
        oportunidades_detectadas = 0
        if asistente.ultimo_analisis and 'resumen_ejecutivo' in asistente.ultimo_analisis:
            oportunidades_detectadas = asistente.ultimo_analisis['resumen_ejecutivo']['oportunidades_detectadas']
        
        return jsonify({
            'status': 'success',
            'message': 'An√°lisis ejecutado exitosamente',
            'timestamp': datetime.now(TIMEZONE).isoformat(),
            'resultados': {
                'oportunidades_detectadas': oportunidades_detectadas,
                'analisis_completado': True,
                'notificacion_enviada': oportunidades_detectadas > 0
            }
        })
    except Exception as e:
        logger.error(f"‚ùå Error en an√°lisis forzado: {e}")
        return jsonify({
            'status': 'error',
            'message': f'Error ejecutando an√°lisis: {str(e)}',
            'timestamp': datetime.now(TIMEZONE).isoformat()
        }), 500

@app.route('/health')
def health():
    """üíö Estado completo del sistema"""
    global asistente
    
    ahora = datetime.now(TIMEZONE)
    tiempo_funcionando = (ahora - asistente.ultima_actualizacion).total_seconds() if asistente.ultima_actualizacion else 0
    
    return jsonify({
        'status': 'healthy',
        'timestamp': ahora.isoformat(),
        'sistema': {
            'nombre': 'Asistente IA Deportiva',
            'version': '4.0.0',
            'ambiente': 'produccion',
            'horario_activo': asistente.es_horario_activo(),
            '] * 100, 1),
                'ganancia_potencial': f"{round((mejor_opcion[2] - 1) * 100, 1)}%"
            },
            'confianza_ia': round(confianza, 1),
            'factores_clave': {
                'forma_reciente': f"Local: {forma_local}% vs Visitante: {forma_visitante}%",
                'rendimiento_casa_visita': f"Casa: {round(rendimiento_casa, 1)}% vs Visita: {round(rendimiento_visita, 1)}%",
                'promedio_goles': f"Local: {round(ataque_local, 1)} vs Visitante: {round(ataque_visitante, 1)}",
                'h2h_ultimos_5': f"{''.join(h2h)} (L=Local, V=Visitante, E=Empate)",
                'bajas': f"Local: {bajas_local} vs Visitante: {bajas_visitante}",
                'ventaja_casa': f"+{int(ventaja_casa_base*100)}% por jugar en casa"
            },
            'recomendacion_ia': self._generar_recomendacion(mejor_opcion, confianza)
        }

    def _analizar_basketball_avanzado(self, partido: Partido) -> Dict:
        """üèÄ An√°lisis avanzado de basketball"""
        stats = partido.estadisticas
        
        # An√°lisis de puntos y eficiencia
        puntos_casa = stats['local']['puntos_promedio_casa']
        puntos_visita = stats['visitante']['puntos_promedio_visita']
        
        defensa_casa = stats['local']['puntos_contra_casa']
        defensa_visita = stats['visitante']['puntos_contra_visita']
        
        # Eficiencia neta
        eficiencia_local = (puntos_casa - defensa_casa) / puntos_casa
        eficiencia_visitante = (puntos_visita - defensa_visita) / puntos_visita
        
        # Factor tiros
        tiros_local = stats['local']['porcentaje_tiros_campo']
        tiros_visitante = stats['visitante']['porcentaje_tiros_campo']
        
        # Ventaja de casa en basketball (menor que f√∫tbol)
        ventaja_casa = 0.08  # 8% ventaja
        
        # Calcular probabilidades
        factor_eficiencia = (eficiencia_local - eficiencia_visitante) * 0.4
        factor_tiros = (tiros_local - tiros_visitante) / 100 * 0.3
        
        prob_local = 0.50 + ventaja_casa + factor_eficiencia + factor_tiros
        prob_local = max(0.15, min(0.85, prob_local))
        prob_visitante = 1 - prob_local
        
        # Valores esperados
        valor_local = self._calcular_valor_esperado(partido.odds_local, prob_local)
        valor_visitante = self._calcular_valor_esperado(partido.odds_visitante, prob_visitante)
        
        mejor_opcion = ('local', valor_local, partido.odds_local, prob_local) if valor_local > valor_visitante else ('visitante', valor_visitante, partido.odds_visitante, prob_visitante)
        
        # Confianza
        diferencia_prob = abs(prob_local - prob_visitante)
        confianza = 70 + diferencia_prob * 40
        
        return {
            'probabilidad_local': round(prob_local * 100, 1),
            'probabilidad_visitante': round(prob_visitante * 100, 1),
            'valor_esperado_local': round(valor_local, 3),
            'valor_esperado_visitante': round(valor_visitante, 3),
            'mejor_apuesta': {
                'opcion': mejor_opcion[0],
                'valor_esperado': round(mejor_opcion[1], 3),
                'odds': mejor_opcion[2],
                'probabilidad': round(mejor_opcion[3
